///////////////////////////////////////////////////////////////////

// OPCODES
    // OPTION
        0NNN => call_assembly_subroutine(address)
            NONE

///////////////////////////////////////////////////////////////////



    8XYE => left_shift(x, y)
        // OPTION
        registers[x] = registers[y]

        if registers[x] & 0b10000000 == 1
            registers[15] = 1
        else
            registers[15] = 0
        registers[x] = registers[x] << 1

///////////////////////////////////////////////////////////////////

    // OPTION
        // OLD
        BNNN => jump_offset(address)
            // OPTION
            program_counter = address + registers[0]

        // NEW
        BXNN => jump_offset(x, address)
            program_counter = address + registers[x]

    CXNN => random(x, value)
        registers[x] = get_random_number() & value

///////////////////////////////////////////////////////////////////

    EX9E => skip_if_key_pressed(x)
        if key_down.get_key_index() == registers[x] && 
            program_counter += 2

    EXA1 => skip_if_key_not_pressed()
        if key_down.get_key_index() != registers[x]
            program_counter += 2

///////////////////////////////////////////////////////////////////

    FX1E => add_to_index(x)
        result = index + registers[x]
        if result > 0xFFF
            registers[15] = 1
        else
            registers[15] = 0
        index = result % 0x1000

    FX0A => get_key(x)
        decrement PC by 2 unless any key pressed
        registers[x] = key_pressed.get_key_index()

    FX29 => character(x)
        index = registers[x] & 0x0F

    FX33 bcd(x)
        registers[x] -> 3 decimal digits 
        store in memory[index]

        example
            // 156 in decimal.
            registers[x] = 0x9C 

            // Using integer division for the truncation.
            memory[index]       = registers[x] / 100
            memory[index + 1]   = (registers[x] / 10) % 10
            memory[index + 2]   = registers[x] % 10

    // OPTION
        // increment index each time (OLD) or leave index alone (NEW)?
        FX55 => store(x)
            for n registers
                memory[index + n] = registers[n]
        FX65 => load(x)
            opposite "